import hashlib
import pyarrow as pa

class MerkleTree:
    def get_proof(self, index: int) -> pa.ListArray:
        """
        Generate a Merkle inclusion proof for a leaf node
        Args:
        index: Leaf node index ÓÇÅ0-based)
        Returns:
        Arrow ListArray of sibling hashes needed to reconstruct root
        Format: [(is_left: bool, hash: bytes), ...]
        """
        if index < 0 or index >= len(self.leaves):
            raise ValueError("Index out of range")
        
        proof = []
        current_idx = index
        current_level = pa.array(self.leaves)
        
        while len(current_level) > 1:
            # Determine sibling position and hash
            is_left = current_idx % 2
            sibling_idx = current_idx - 1 if is_left else current_idx + 1
            
            # Handle odd-length levels
            if sibling_idx >= len(current_level):
                sibling_hash = current_level[current_idx]
            else:
                sibling_hash = current_level[sibling_idx]
            # Store proof element with positional flag
            proof.append(pa.struct([
                ('is_left', pa.scalar(not is_left)),
                ('hash', sibling_hash)
            ]))

            # Move up to parent level
            current_idx = current_idx // 2
            current_level = pa.array([
                self._hash(current_level[i] + current_level[i+1])
                for i in range(0, len(current_level), 2)
            ], type=pa.binary())
        return pa.ListArray.from_arrays(proof)

    @staticmethod
    def verify(root: bytes, leaf: bytes, proof: pa.ListArray) -> bool:
        """
        Verify Merkle proof against known root hash
        Args:
        root: Known root hash as bytes
        leaf: Leaf node content as bytes
        proof: Proof generated by get_proof()
        """
        current = hashlib.sha256(leaf).digest()
        for node in proof:
            if node['is_left'].as_py():
                current = hashlib.sha256(node['hash'].as_py() + current).digest()
            else:
                current = hashlib.sha256(current + node['hash'].as_py()).digest()
        return current == root